import { autorun, observable, computed, action } from 'mobx';import uuid from 'uuid';import Immutable from 'immutable';import _ from 'lodash';import { betStore, profileStore, appSettingStore } from "./index";export default class SocketStore {    @observable messageList: Array = [];    @observable userMessageList: Array = [];    constructor () {        this.socket = null;        this.onOpenWebSocket = this.onOpenWebSocket.bind(this);        this.onReceiveMessage = this.onReceiveMessage.bind(this);        this.onCloseSocket = this.onCloseSocket.bind(this);        this.concatNewMessage = this.concatNewMessage.bind(this);        this.updateMessageStatus = this.updateMessageStatus.bind(this);    }    @action    connectWebSocket () {        const { tcpUrl} = betStore.roomInfo;        try {            this.socket = new WebSocket(tcpUrl);            this.socket.addEventListener('open', this.onOpenWebSocket);            this.socket.addEventListener('message', this.onReceiveMessage);            this.socket.addEventListener('close', this.onCloseSocket);        } catch (err) {            console.log('connect web socket fail', err)        }    }    onOpenWebSocket () {        const { userId, username, avatar, level } = profileStore.userInfo;        const { roomId } = betStore.roomInfo;        const appName = appSettingStore.appSettings.appName || '';        try {            this.socket.send(JSON.stringify({                // act: 1, //类型: 101建立房间连接，102发送消息                act: 101,                appName,                appRoomId: roomId,                actId: uuid(),                user: {                    userId,                    userName: username,                    userAvatar: avatar,                    userLevelId: level                }            }));        } catch (e) {            console.log('open web socket fail', e)        }    }    onReceiveMessage (event) {        const { userId } = profileStore.userInfo;        try{            const newMessage = JSON.parse(event.data);            //1注单，2聊天消息，3系统通知，4开奖通知，5 响应客户端请求，            switch (newMessage.type) {                case 1:                case 2:                    if (newMessage.user && newMessage.user.userId !== userId) {                        this.concatNewMessage(newMessage);                    }                    break;                case 3:                    this.concatNewMessage(newMessage);                    break;                case 4:                    this.concatNewMessage(newMessage);                    betStore.getHistoryLotteryList();                    setTimeout( profileStore.fetchUserInfo, 1500);                    break;                case 5:                    if (newMessage.data.subscribeName) {                        this.socket.subscribeName = newMessage.data.subscribeName;                    } else {                        this.updateMessageStatus(newMessage.data.actId, newMessage.data.status);                    }                    break;            }        }catch(e) {            console.log(e)        }    }    onCloseSocket () {        console.log('web socket closed')    }    @action stopWebSocket() {        if (this.socket) {            this.socket.removeEventListener('open');            this.socket.removeEventListener('message');            this.socket.removeEventListener('close');            this.socket.close();        }    }    @action sendSocketMessage (newMessage) {        try {            this.socket.send(JSON.stringify(_.merge({                act: '102',                subscribeName: this.socket.subscribeName            }, newMessage)));        } catch (err) {            console.log('send socket message err', err)        }    }    splitMessageForChat (msg,status) {        const { userId, username, avatar, level } = profileStore.userInfo;        const user = { userId, username, avatar,level };        const {actId, type, textMessage, orderMessage, orderDetail} = msg;        const newMessage = {            actId,            user,            messageStatus: {                position: 'right',                status: status === 'none' ? 'fail' : 'loading'            }        };        if (type === 1) {            newMessage.orderMessage = orderMessage;            newMessage.orderDetail = orderDetail;            newMessage.messageStatus.typeDesc = 'order'        } else if (type === 2 ){            newMessage.textMessage = textMessage;            newMessage.messageStatus.typeDesc = 'message'        }        this.concatNewMessage(newMessage);        return {            actId,            message: {                type,                user,                messageStatus: newMessage.messageStatus,                orderMessage,                orderDetail,                textMessage            }        };    }    concatNewMessage (newMessage) {        const messageList = Immutable.fromJS(this.messageList).toJS();        const len = messageList.length;        const { actId } = newMessage;        !!actId && this.userMessageList.push({index: len, actId});        this.messageList = [...messageList, newMessage]    }    updateMessageStatus (actId, status, orderDetail) {        let messageList = Immutable.fromJS(this.messageList).toJS();        this.userMessageList.forEach((elem, index) => {            if (elem.actId === actId) {                if (!!orderDetail) {messageList[elem.index].orderDetail = orderDetail}                messageList[elem.index].messageStatus.status = status ? 'success' : 'fail';                this.messageList = messageList;                status && delete this.userMessageList[index];            }        })    }    cleanMessageList () {        this.messageList =[];    }}